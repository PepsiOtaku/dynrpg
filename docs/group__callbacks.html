<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.12.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DynRPG: Callbacks</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link rel="icon" href="favicon.ico" type="image/x-icon" />
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectlogo"><img alt="Logo" src="DynRPG_logo_webPepsiOtaku.png"  /></td>
              <td id="projectalign">
                <div id="projectname">DynRPG<span
                    id="projectnumber">&#160;v0.32 Unofficial</span>
                </div>
                <div id="projectbrief">Plugin SDK</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Callbacks</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8a8edd989b9169752c0239bbadb3f9fd" id="r_ga8a8edd989b9169752c0239bbadb3f9fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8a8edd989b9169752c0239bbadb3f9fd">onStartup</a> (char *pluginName)</td></tr>
<tr class="memdesc:ga8a8edd989b9169752c0239bbadb3f9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the plugin was loaded.  <br /></td></tr>
<tr class="separator:ga8a8edd989b9169752c0239bbadb3f9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae450b4810c6bb042969e4e15297c905f" id="r_gae450b4810c6bb042969e4e15297c905f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae450b4810c6bb042969e4e15297c905f">onInitFinished</a> ()</td></tr>
<tr class="memdesc:gae450b4810c6bb042969e4e15297c905f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the <a class="el" href="namespace_r_p_g.html" title="The one and only namespace in which all DynRPG classes, variables and functions reside,...">RPG</a> objects were initialized.  <br /></td></tr>
<tr class="separator:gae450b4810c6bb042969e4e15297c905f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a8ae4b9e3b382e3494773c670e3f19" id="r_ga14a8ae4b9e3b382e3494773c670e3f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga14a8ae4b9e3b382e3494773c670e3f19">onInitTitleScreen</a> ()</td></tr>
<tr class="memdesc:ga14a8ae4b9e3b382e3494773c670e3f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the title screen is initialized.  <br /></td></tr>
<tr class="separator:ga14a8ae4b9e3b382e3494773c670e3f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf286710eea5356161c7790be7ca3e943" id="r_gaf286710eea5356161c7790be7ca3e943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf286710eea5356161c7790be7ca3e943">onLoadGame</a> (int id, char *data, int length)</td></tr>
<tr class="memdesc:gaf286710eea5356161c7790be7ca3e943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the player loads a game from a savestate.  <br /></td></tr>
<tr class="separator:gaf286710eea5356161c7790be7ca3e943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec141f78a287175b08e49f2e6b09e857" id="r_gaec141f78a287175b08e49f2e6b09e857"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaec141f78a287175b08e49f2e6b09e857">onSaveGame</a> (int id, void(*savePluginData)(char *data, int length))</td></tr>
<tr class="memdesc:gaec141f78a287175b08e49f2e6b09e857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the player saves a game.  <br /></td></tr>
<tr class="separator:gaec141f78a287175b08e49f2e6b09e857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7dcec3988ba4d873f365b75373e5b09" id="r_gaf7dcec3988ba4d873f365b75373e5b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf7dcec3988ba4d873f365b75373e5b09">onExit</a> ()</td></tr>
<tr class="memdesc:gaf7dcec3988ba4d873f365b75373e5b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the game exits.  <br /></td></tr>
<tr class="separator:gaf7dcec3988ba4d873f365b75373e5b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ae5dd898c9423e63b28febef915cb4" id="r_ga80ae5dd898c9423e63b28febef915cb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga80ae5dd898c9423e63b28febef915cb4">onFrame</a> (<a class="el" href="namespace_r_p_g.html#a2385fd16f4ad88a4166fc9d04255a88c">RPG::Scene</a> scene)</td></tr>
<tr class="memdesc:ga80ae5dd898c9423e63b28febef915cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called every frame, before the screen is refreshed (see details!)  <br /></td></tr>
<tr class="separator:ga80ae5dd898c9423e63b28febef915cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e95403edc3221cf53acafc5013db49" id="r_ga78e95403edc3221cf53acafc5013db49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga78e95403edc3221cf53acafc5013db49">onSetVariable</a> (int id, int value)</td></tr>
<tr class="memdesc:ga78e95403edc3221cf53acafc5013db49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before an in-game variable is set.  <br /></td></tr>
<tr class="separator:ga78e95403edc3221cf53acafc5013db49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga132e4983697a2aa0b0b979cc36e19d68" id="r_ga132e4983697a2aa0b0b979cc36e19d68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga132e4983697a2aa0b0b979cc36e19d68">onSetSwitch</a> (int id, bool value)</td></tr>
<tr class="memdesc:ga132e4983697a2aa0b0b979cc36e19d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before an in-game switch is set.  <br /></td></tr>
<tr class="separator:ga132e4983697a2aa0b0b979cc36e19d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc31ffa472b1c78134e9d29a08a8bdc6" id="r_gacc31ffa472b1c78134e9d29a08a8bdc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacc31ffa472b1c78134e9d29a08a8bdc6">onEventCommand</a> (<a class="el" href="class_r_p_g_1_1_event_script_line.html">RPG::EventScriptLine</a> *scriptLine, <a class="el" href="class_r_p_g_1_1_event_script_data.html">RPG::EventScriptData</a> *scriptData, int eventId, int pageId, int lineId, int *nextLineId)</td></tr>
<tr class="memdesc:gacc31ffa472b1c78134e9d29a08a8bdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before an event command is executed.  <br /></td></tr>
<tr class="separator:gacc31ffa472b1c78134e9d29a08a8bdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae23e92c109881bcec43cfb2838f3aead" id="r_gae23e92c109881bcec43cfb2838f3aead"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae23e92c109881bcec43cfb2838f3aead">onComment</a> (const char *text, const <a class="el" href="class_r_p_g_1_1_parsed_comment_data.html">RPG::ParsedCommentData</a> *parsedData, <a class="el" href="class_r_p_g_1_1_event_script_line.html">RPG::EventScriptLine</a> *nextScriptLine, <a class="el" href="class_r_p_g_1_1_event_script_data.html">RPG::EventScriptData</a> *scriptData, int eventId, int pageId, int lineId, int *nextLineId)</td></tr>
<tr class="memdesc:gae23e92c109881bcec43cfb2838f3aead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a "Comment" event command is encountered.  <br /></td></tr>
<tr class="separator:gae23e92c109881bcec43cfb2838f3aead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga112b9068cd1e942a959f4c6f0865f1f0" id="r_ga112b9068cd1e942a959f4c6f0865f1f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga112b9068cd1e942a959f4c6f0865f1f0">onDrawScreen</a> ()</td></tr>
<tr class="memdesc:ga112b9068cd1e942a959f4c6f0865f1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the screen is drawn on the game window.  <br /></td></tr>
<tr class="separator:ga112b9068cd1e942a959f4c6f0865f1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ad686df799b1dd99171611a62fd493" id="r_gac6ad686df799b1dd99171611a62fd493"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac6ad686df799b1dd99171611a62fd493">onDrawPicture</a> (<a class="el" href="class_r_p_g_1_1_picture.html">RPG::Picture</a> *picture)</td></tr>
<tr class="memdesc:gac6ad686df799b1dd99171611a62fd493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before a picture is drawn.  <br /></td></tr>
<tr class="separator:gac6ad686df799b1dd99171611a62fd493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54637c43929854413291a8e47a1c5ea" id="r_gad54637c43929854413291a8e47a1c5ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad54637c43929854413291a8e47a1c5ea">onPictureDrawn</a> (<a class="el" href="class_r_p_g_1_1_picture.html">RPG::Picture</a> *picture)</td></tr>
<tr class="memdesc:gad54637c43929854413291a8e47a1c5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a picture was drawn (or was supposed to be drawn)  <br /></td></tr>
<tr class="separator:gad54637c43929854413291a8e47a1c5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862305d7d40b374d0001a7aa47d7402f" id="r_ga862305d7d40b374d0001a7aa47d7402f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga862305d7d40b374d0001a7aa47d7402f">onCheckEventVisibility</a> (<a class="el" href="class_r_p_g_1_1_character.html">RPG::Character</a> *character)</td></tr>
<tr class="memdesc:ga862305d7d40b374d0001a7aa47d7402f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called every frame to check whether an event should be drawn even though it is out of sight.  <br /></td></tr>
<tr class="separator:ga862305d7d40b374d0001a7aa47d7402f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f6125de459664a48e7c39f088f9a51" id="r_ga32f6125de459664a48e7c39f088f9a51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga32f6125de459664a48e7c39f088f9a51">onDrawEvent</a> (<a class="el" href="class_r_p_g_1_1_character.html">RPG::Character</a> *character, bool isHero)</td></tr>
<tr class="memdesc:ga32f6125de459664a48e7c39f088f9a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before an event or the hero is drawn.  <br /></td></tr>
<tr class="separator:ga32f6125de459664a48e7c39f088f9a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c58b7f06ed7fc5c987a2008bbb8d52" id="r_ga44c58b7f06ed7fc5c987a2008bbb8d52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga44c58b7f06ed7fc5c987a2008bbb8d52">onEventDrawn</a> (<a class="el" href="class_r_p_g_1_1_character.html">RPG::Character</a> *character, bool isHero)</td></tr>
<tr class="memdesc:ga44c58b7f06ed7fc5c987a2008bbb8d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after an event or the hero was drawn (or was supposed to be drawn)  <br /></td></tr>
<tr class="separator:ga44c58b7f06ed7fc5c987a2008bbb8d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3170afc9755edc6b80151a3e21132118" id="r_ga3170afc9755edc6b80151a3e21132118"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3170afc9755edc6b80151a3e21132118">onDrawBattler</a> (<a class="el" href="class_r_p_g_1_1_battler.html">RPG::Battler</a> *battler, bool isMonster, int id)</td></tr>
<tr class="memdesc:ga3170afc9755edc6b80151a3e21132118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before a battler is drawn.  <br /></td></tr>
<tr class="separator:ga3170afc9755edc6b80151a3e21132118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7156e34fef971c0ef925491981bb33c4" id="r_ga7156e34fef971c0ef925491981bb33c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7156e34fef971c0ef925491981bb33c4">onBattlerDrawn</a> (<a class="el" href="class_r_p_g_1_1_battler.html">RPG::Battler</a> *battler, bool isMonster, int id)</td></tr>
<tr class="memdesc:ga7156e34fef971c0ef925491981bb33c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a battler was drawn (or supposed to be drawn)  <br /></td></tr>
<tr class="separator:ga7156e34fef971c0ef925491981bb33c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80abe9c0464a6595d2ecc3d258948d0c" id="r_ga80abe9c0464a6595d2ecc3d258948d0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga80abe9c0464a6595d2ecc3d258948d0c">onDrawBattleStatusWindow</a> (int x, int selection, bool selActive, bool isTargetSelection, bool isVisible)</td></tr>
<tr class="memdesc:ga80abe9c0464a6595d2ecc3d258948d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the battle status window is drawn.  <br /></td></tr>
<tr class="separator:ga80abe9c0464a6595d2ecc3d258948d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28b0a6a4f86b757615b941c36d51a488" id="r_ga28b0a6a4f86b757615b941c36d51a488"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga28b0a6a4f86b757615b941c36d51a488">onBattleStatusWindowDrawn</a> (int x, int selection, bool selActive, bool isTargetSelection, bool isVisible)</td></tr>
<tr class="memdesc:ga28b0a6a4f86b757615b941c36d51a488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the battle status window was drawn (or supposed to be drawn)  <br /></td></tr>
<tr class="separator:ga28b0a6a4f86b757615b941c36d51a488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07405966d69ea314beb92a1213acca79" id="r_ga07405966d69ea314beb92a1213acca79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga07405966d69ea314beb92a1213acca79">onDrawBattleActionWindow</a> (int *x, int *y, int selection, bool selActive, bool isVisible)</td></tr>
<tr class="memdesc:ga07405966d69ea314beb92a1213acca79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the battle action window is drawn.  <br /></td></tr>
<tr class="separator:ga07405966d69ea314beb92a1213acca79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f86370031d3d7e644e14a0259e17a3" id="r_ga63f86370031d3d7e644e14a0259e17a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga63f86370031d3d7e644e14a0259e17a3">onDoBattlerAction</a> (<a class="el" href="class_r_p_g_1_1_battler.html">RPG::Battler</a> *battler, bool firstTry)</td></tr>
<tr class="memdesc:ga63f86370031d3d7e644e14a0259e17a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before a battler's action is executed.  <br /></td></tr>
<tr class="separator:ga63f86370031d3d7e644e14a0259e17a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e545a389a677aac2260f0b2d88c5cf0" id="r_ga9e545a389a677aac2260f0b2d88c5cf0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9e545a389a677aac2260f0b2d88c5cf0">onBattlerActionDone</a> (<a class="el" href="class_r_p_g_1_1_battler.html">RPG::Battler</a> *battler, bool success)</td></tr>
<tr class="memdesc:ga9e545a389a677aac2260f0b2d88c5cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a battler's action is executed.  <br /></td></tr>
<tr class="separator:ga9e545a389a677aac2260f0b2d88c5cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga841f39d05129ab6f15b2d15358855f2a" id="r_ga841f39d05129ab6f15b2d15358855f2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga841f39d05129ab6f15b2d15358855f2a">onSystemBackgroundDrawn</a> (RECT *rect)</td></tr>
<tr class="memdesc:ga841f39d05129ab6f15b2d15358855f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the system background was drawn.  <br /></td></tr>
<tr class="separator:ga841f39d05129ab6f15b2d15358855f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9e545a389a677aac2260f0b2d88c5cf0" name="ga9e545a389a677aac2260f0b2d88c5cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e545a389a677aac2260f0b2d88c5cf0">&#9670;&#160;</a></span>onBattlerActionDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onBattlerActionDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_battler.html">RPG::Battler</a> *</td>          <td class="paramname"><span class="paramname"><em>battler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>success</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called after a battler's action is executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">battler</td><td>The battler which is executing its action </td></tr>
    <tr><td class="paramname">success</td><td><code>true</code> if the action was successfully executed or <code>false</code> if the action couldn't be executed yet because another action or something else was active </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>success</code> if <code>false</code>, the RPG Maker will repeatedly try again to execute the action, until it succeeds, at which point <code>success</code> will be <code>true</code>. Please note that this will also lead to multiple calls to <a class="el" href="#ga63f86370031d3d7e644e14a0259e17a3">onDoBattlerAction</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You must not modify the battler's action from this function, because it might not be <em>fully</em> completed. For example, "Attack" commands will immediately be finished although the attack animation and damage display haven't been done yet. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga63f86370031d3d7e644e14a0259e17a3" title="Called before a battler&#39;s action is executed.">onDoBattlerAction</a> </dd>
<dd>
<a class="el" href="class_r_p_g_1_1_action.html" title="Action of a battler (normal attack, skill, escape, etc.), including target">RPG::Action</a> </dd></dl>

</div>
</div>
<a id="ga7156e34fef971c0ef925491981bb33c4" name="ga7156e34fef971c0ef925491981bb33c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7156e34fef971c0ef925491981bb33c4">&#9670;&#160;</a></span>onBattlerDrawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onBattlerDrawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_battler.html">RPG::Battler</a> *</td>          <td class="paramname"><span class="paramname"><em>battler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isMonster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called after a battler was drawn (or supposed to be drawn) </p>
<p>You can use this function to draw something above a certain battler. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">battler</td><td>The battler which was drawn (or supposed to be drawn) </td></tr>
    <tr><td class="paramname">isMonster</td><td><code>true</code> if the <code>battler</code> is a monster </td></tr>
    <tr><td class="paramname">id</td><td>Zero-based party member ID of the <code>battler</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function will be called regardless if a plugin returned <code>false</code> from its <a class="el" href="#ga3170afc9755edc6b80151a3e21132118">onDrawBattler</a> handler for this event.<br  />
<br  />
This function is not called for hidden monsters. For dead monsters it is only called while they are still partly visible (i.e. while they are fading out). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga3170afc9755edc6b80151a3e21132118" title="Called before a battler is drawn.">onDrawBattler</a> </dd></dl>

</div>
</div>
<a id="ga28b0a6a4f86b757615b941c36d51a488" name="ga28b0a6a4f86b757615b941c36d51a488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28b0a6a4f86b757615b941c36d51a488">&#9670;&#160;</a></span>onBattleStatusWindowDrawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onBattleStatusWindowDrawn </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>selection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>selActive</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isTargetSelection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isVisible</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called after the battle status window was drawn (or supposed to be drawn) </p>
<p>You can use this function to draw something above the battle status window. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The current X coordinate of the left side of the window </td></tr>
    <tr><td class="paramname">selection</td><td>The zero-based party member ID of the currently selecter actor </td></tr>
    <tr><td class="paramname">selActive</td><td><code>true</code> if the <code>selection</code> parameter contains a valid value and a choice bar is drawn </td></tr>
    <tr><td class="paramname">isTargetSelection</td><td><code>true</code> if it is the target selection window, <code>false</code> if it is the "normal" status window </td></tr>
    <tr><td class="paramname">isVisible</td><td><code>true</code> if the window is visible </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function will be called regardless if a plugin returned <code>false</code> from its <a class="el" href="#ga80abe9c0464a6595d2ecc3d258948d0c">onDrawBattleStatusWindow</a> handler for this window.<br  />
<br  />
This function is also called when the window is invisible. In this case, <code>isVisible</code> will be <code>false</code>.<br  />
<br  />
Please see the <a class="el" href="#ga80abe9c0464a6595d2ecc3d258948d0c">onDrawBattleStatusWindow</a> documentation to find out more about the <code>isTargetSelection</code> parameter! </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga80abe9c0464a6595d2ecc3d258948d0c" title="Called before the battle status window is drawn.">onDrawBattleStatusWindow</a> </dd></dl>

</div>
</div>
<a id="ga862305d7d40b374d0001a7aa47d7402f" name="ga862305d7d40b374d0001a7aa47d7402f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga862305d7d40b374d0001a7aa47d7402f">&#9670;&#160;</a></span>onCheckEventVisibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onCheckEventVisibility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_character.html">RPG::Character</a> *</td>          <td class="paramname"><span class="paramname"><em>character</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called every frame to check whether an event should be drawn even though it is out of sight. </p>
<p>Use this function in case you want to draw larger graphics instead of an event's normal graphic (using <a class="el" href="#ga32f6125de459664a48e7c39f088f9a51">onDrawEvent</a>). Normally, events which are out of sight are not drawn at all, thus neither <a class="el" href="#ga32f6125de459664a48e7c39f088f9a51">onDrawEvent</a> nor <a class="el" href="#ga44c58b7f06ed7fc5c987a2008bbb8d52">onEventDrawn</a> would be called for this event. Return <code>false</code> from this function to force the drawing of the event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The event to be drawn (can also be the hero) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> <b>if the event should be drawn</b> even though it is out of sight and also to prevent other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not initiate any actions from this function, only check whether you need to draw this event or not. If a previous plugin returned <code>false</code>, your plugin won't receive this notification, even though it might receive the <a class="el" href="#ga32f6125de459664a48e7c39f088f9a51">onDrawEvent</a> and <a class="el" href="#ga44c58b7f06ed7fc5c987a2008bbb8d52">onEventDrawn</a> notifications! </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga32f6125de459664a48e7c39f088f9a51" title="Called before an event or the hero is drawn.">onDrawEvent</a> </dd>
<dd>
<a class="el" href="#ga44c58b7f06ed7fc5c987a2008bbb8d52" title="Called after an event or the hero was drawn (or was supposed to be drawn)">onEventDrawn</a> </dd></dl>

</div>
</div>
<a id="gae23e92c109881bcec43cfb2838f3aead" name="gae23e92c109881bcec43cfb2838f3aead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae23e92c109881bcec43cfb2838f3aead">&#9670;&#160;</a></span>onComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onComment </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_r_p_g_1_1_parsed_comment_data.html">RPG::ParsedCommentData</a> *</td>          <td class="paramname"><span class="paramname"><em>parsedData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_event_script_line.html">RPG::EventScriptLine</a> *</td>          <td class="paramname"><span class="paramname"><em>nextScriptLine</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_event_script_data.html">RPG::EventScriptData</a> *</td>          <td class="paramname"><span class="paramname"><em>scriptData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>eventId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pageId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lineId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>nextLineId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a "Comment" event command is encountered. </p>
<p>You can use this function to provide functions which are executed when a special event comment is encountered. Please stick to the <a class="el" href="guidelines.html#event_comments">Event comments</a> guidelines! The <code>parsedData</code> parameter brings you the data already parsed according to the guidelines.</p>
<p>You will get all comment lines at once (separated by newline characters) in the <code>text</code> parameter. This way you don't need to do the parsing of the next event script lines (because internally, each comment line is a new event command).</p>
<p>You may use the comment function as "modifier" for event commands, thus there is the <code>nextScriptLine</code> parameter which allows you to modify the parameters of the next script line. For modifying event commands please also read the note at the <a class="el" href="#gacc31ffa472b1c78134e9d29a08a8bdc6">onEventCommand</a> documentation!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The comment's content as simple text </td></tr>
    <tr><td class="paramname">parsedData</td><td>The already parsed data </td></tr>
    <tr><td class="paramname">nextScriptLine</td><td>The next event script line after the comment </td></tr>
    <tr><td class="paramname">scriptData</td><td>Pointer to the <a class="el" href="class_r_p_g_1_1_event_script_data.html" title="Class used for the event script data of an event.">RPG::EventScriptData</a> object of the current event script </td></tr>
    <tr><td class="paramname">eventId</td><td>The ID of the current event (negative for common events, zero for battle events) </td></tr>
    <tr><td class="paramname">pageId</td><td>The ID of the current event page (zero for common and battle events - sorry, no battle event page ID yet) </td></tr>
    <tr><td class="paramname">lineId</td><td>The zero-based line number </td></tr>
    <tr><td class="paramname">nextLineId</td><td>Pointer to the next executed line number (<code>-1</code> for default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For information how to use the <code>nextLineId</code> parameter, please refer to the <a class="el" href="#gacc31ffa472b1c78134e9d29a08a8bdc6">onEventCommand</a> documentation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gacc31ffa472b1c78134e9d29a08a8bdc6" title="Called before an event command is executed.">onEventCommand</a> </dd></dl>

</div>
</div>
<a id="ga63f86370031d3d7e644e14a0259e17a3" name="ga63f86370031d3d7e644e14a0259e17a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63f86370031d3d7e644e14a0259e17a3">&#9670;&#160;</a></span>onDoBattlerAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onDoBattlerAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_battler.html">RPG::Battler</a> *</td>          <td class="paramname"><span class="paramname"><em>battler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>firstTry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before a battler's action is executed. </p>
<p>This function can be used to modify a battler's action before it is executed. For example, you might add a "random" skill which randomly executes certain skills and use this function to set the actual skill. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">battler</td><td>The battler which is executing its action </td></tr>
    <tr><td class="paramname">firstTry</td><td><code>true</code> if this is the first attempt to execute this action. Make sure you include a check for this parameter to be <code>true</code> if you want your code to be run only once per action! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If executing the action fails (due to another action being executed), the RPG Maker will repeatedly try again. You will then receive multiple calls to this callback, but only at the first call <code>firstTry</code> will be set to <code>true</code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Using this function, you can also use targets for a skill (or the "Attack" and "Double Attack" functions) which are normally not possible.<br  />
<br  />
To prevent an action completely, change it to the basic action <a class="el" href="namespace_r_p_g.html#a78c15e5c25315de95f673dbd5d3561d3a674e7aeeefb92a2ed45142af763d65a8" title="No action.">RPG::BA_NONE</a>. Do not use <a class="el" href="namespace_r_p_g.html#aada1d31d438af28ab18ec12ceabec835a5e7f28d8eb880271008d73b5677a5a54" title="No action (last action was already executed)">RPG::AK_NONE</a> because this can cause errors later in the battle. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga9e545a389a677aac2260f0b2d88c5cf0" title="Called after a battler&#39;s action is executed.">onBattlerActionDone</a> </dd>
<dd>
<a class="el" href="class_r_p_g_1_1_action.html" title="Action of a battler (normal attack, skill, escape, etc.), including target">RPG::Action</a> </dd></dl>

</div>
</div>
<a id="ga07405966d69ea314beb92a1213acca79" name="ga07405966d69ea314beb92a1213acca79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07405966d69ea314beb92a1213acca79">&#9670;&#160;</a></span>onDrawBattleActionWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onDrawBattleActionWindow </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>selection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>selActive</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isVisible</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before the battle action window is drawn. </p>
<p>You can use this function to draw below the battle action window, or to replace it entirely.</p>
<p>You can also use this function to move the window by modifying <code>*x</code> and <code>*y</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the X coordinate of the upper-left corner of the window </td></tr>
    <tr><td class="paramname">y</td><td>Pointer to the Y coordinate of the upper-right corner of the window </td></tr>
    <tr><td class="paramname">selection</td><td>Zero-based index of the current selection </td></tr>
    <tr><td class="paramname">selActive</td><td><code>true</code> if the <code>selection</code> parameter contains a valid value and a choice bar is drawn </td></tr>
    <tr><td class="paramname">isVisible</td><td><code>true</code> if the window is visible </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent the original window from being drawn and other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>selection</code> parameter does <b>not</b> contain the database ID of the selected battle command, but only a zero-based index based on all choices which are displayed. Use the <a class="el" href="class_r_p_g_1_1_actor.html" title="Used for the data of actors which can be changed in-game.">RPG::Actor</a> object to find out which battle commands are available for an actor. You probably need to store the <code>selection</code> parameter from your <a class="el" href="#ga80abe9c0464a6595d2ecc3d258948d0c">onDrawBattleStatusWindow</a> to find out which actor is currently selected. You can then use something like <code>RPG::Actor::partyMember(battleStatusWindowSelection)-&gt;getBattleCommand(battleActionWindowSelection)</code> to get the database ID of the currently selected battle command.<br  />
<br  />
This function is also called when the window is invisible. In this case, <code>isVisible</code> will be <code>false</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga28b0a6a4f86b757615b941c36d51a488" title="Called after the battle status window was drawn (or supposed to be drawn)">onBattleStatusWindowDrawn</a> </dd></dl>

</div>
</div>
<a id="ga3170afc9755edc6b80151a3e21132118" name="ga3170afc9755edc6b80151a3e21132118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3170afc9755edc6b80151a3e21132118">&#9670;&#160;</a></span>onDrawBattler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onDrawBattler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_battler.html">RPG::Battler</a> *</td>          <td class="paramname"><span class="paramname"><em>battler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isMonster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before a battler is drawn. </p>
<p>You can use this function to draw something below a certain battler, or instead of the battler. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">battler</td><td>The battler which is about to be drawn </td></tr>
    <tr><td class="paramname">isMonster</td><td><code>true</code> if the <code>battler</code> is a monster </td></tr>
    <tr><td class="paramname">id</td><td>Zero-based party member ID of the <code>battler</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent the original battler from being drawn and other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you return <code>false</code>, the <a class="el" href="#ga7156e34fef971c0ef925491981bb33c4">onBattlerDrawn</a> handlers will still be called.<br  />
<br  />
This function is not called for hidden monsters. For dead monsters it is only called while they are still partly visible (i.e. while they are fading out). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7156e34fef971c0ef925491981bb33c4" title="Called after a battler was drawn (or supposed to be drawn)">onBattlerDrawn</a> </dd></dl>

</div>
</div>
<a id="ga80abe9c0464a6595d2ecc3d258948d0c" name="ga80abe9c0464a6595d2ecc3d258948d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80abe9c0464a6595d2ecc3d258948d0c">&#9670;&#160;</a></span>onDrawBattleStatusWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onDrawBattleStatusWindow </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>selection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>selActive</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isTargetSelection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isVisible</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before the battle status window is drawn. </p>
<p>You can use this function to draw below the battle status window, or to replace it entirely.</p>
<p>In the "Traditional" and "Alternative" battle layouts, there are two different status windows: One used as actual <em>status</em> window, one used as target selection window for actions with actors as targets. The latter is drawn <em>above</em> the skill/item selection window, while the former is drawn <em>below</em> it. Use the <code>isTargetSelection</code> parameter to find out which window you are dealing with.</p>
<p>You can also use this function (when <code>isTargetSelection</code> is <code>false</code>) to draw something above all battlers and below all windows. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The current X coordinate of the left side of the window </td></tr>
    <tr><td class="paramname">selection</td><td>The zero-based party member ID of the currently selected actor </td></tr>
    <tr><td class="paramname">selActive</td><td><code>true</code> if the <code>selection</code> parameter contains a valid value and a choice bar is drawn </td></tr>
    <tr><td class="paramname">isTargetSelection</td><td><code>true</code> if it is the target selection window, <code>false</code> if it is the "normal" status window </td></tr>
    <tr><td class="paramname">isVisible</td><td><code>true</code> if the window is visible </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent the original window from being drawn and other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you return <code>false</code>, the <a class="el" href="#ga28b0a6a4f86b757615b941c36d51a488">onBattleStatusWindowDrawn</a> handlers will still be called. However, the "finger" cursor which points to the selected hero will not be drawn if you return <code>false</code> when the <code>isTargetSelection</code> parameter is <code>true</code>.<br  />
<br  />
This function is also called when the window is invisible. In this case, <code>isVisible</code> will be <code>false</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga28b0a6a4f86b757615b941c36d51a488" title="Called after the battle status window was drawn (or supposed to be drawn)">onBattleStatusWindowDrawn</a> </dd></dl>

</div>
</div>
<a id="ga32f6125de459664a48e7c39f088f9a51" name="ga32f6125de459664a48e7c39f088f9a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32f6125de459664a48e7c39f088f9a51">&#9670;&#160;</a></span>onDrawEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onDrawEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_character.html">RPG::Character</a> *</td>          <td class="paramname"><span class="paramname"><em>character</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isHero</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before an event or the hero is drawn. </p>
<p>You can use this function to draw something below a certain event, or instead of the event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character which is about to be drawn (can also be the hero) </td></tr>
    <tr><td class="paramname">isHero</td><td><code>true</code> if the <code>character</code> is the hero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent the original event from being drawn and other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you return <code>false</code>, the <a class="el" href="#ga44c58b7f06ed7fc5c987a2008bbb8d52">onEventDrawn</a> handlers will still be called.<br  />
<br  />
Vehicles are not supported yet.<br  />
<br  />
This function is only called when the event is in sight <em>or</em> an <a class="el" href="#ga862305d7d40b374d0001a7aa47d7402f">onCheckEventVisibility</a> handler has returned <code>false</code> for this event. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga44c58b7f06ed7fc5c987a2008bbb8d52" title="Called after an event or the hero was drawn (or was supposed to be drawn)">onEventDrawn</a> </dd></dl>

</div>
</div>
<a id="gac6ad686df799b1dd99171611a62fd493" name="gac6ad686df799b1dd99171611a62fd493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6ad686df799b1dd99171611a62fd493">&#9670;&#160;</a></span>onDrawPicture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onDrawPicture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_picture.html">RPG::Picture</a> *</td>          <td class="paramname"><span class="paramname"><em>picture</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before a picture is drawn. </p>
<p>You can use this function to draw something below a certain picture, or instead of the picture. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">picture</td><td>The picture which is about to be drawn </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent the original picture from being drawn and other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you return <code>false</code>, the <a class="el" href="#gad54637c43929854413291a8e47a1c5ea">onPictureDrawn</a> handlers will still be called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gad54637c43929854413291a8e47a1c5ea" title="Called after a picture was drawn (or was supposed to be drawn)">onPictureDrawn</a> </dd></dl>

</div>
</div>
<a id="ga112b9068cd1e942a959f4c6f0865f1f0" name="ga112b9068cd1e942a959f4c6f0865f1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga112b9068cd1e942a959f4c6f0865f1f0">&#9670;&#160;</a></span>onDrawScreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void onDrawScreen </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when the screen is drawn on the game window. </p>
<p>Unlike <a class="el" href="#ga80ae5dd898c9423e63b28febef915cb4">onFrame</a>, this function is called when the screen content is actually drawn on the game window. This means that if a section of the window is invalidated (for example because it was overlapped by another window or minimized), this function will be called again, even though the game screen itself didn't change. </p><dl class="section warning"><dt>Warning</dt><dd>The screen might already contain changes done by you in the <a class="el" href="#ga112b9068cd1e942a959f4c6f0865f1f0">onDrawScreen</a> handler before. Also, it is possible that only a <em>part</em> of the screen is invalidated and redrawn. Thus, you should only use this callback if you need to draw something during certain screen transitions (where <a class="el" href="#ga80ae5dd898c9423e63b28febef915cb4">onFrame</a> doesn't work). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga80ae5dd898c9423e63b28febef915cb4" title="Called every frame, before the screen is refreshed (see details!)">onFrame</a> </dd></dl>

</div>
</div>
<a id="gacc31ffa472b1c78134e9d29a08a8bdc6" name="gacc31ffa472b1c78134e9d29a08a8bdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc31ffa472b1c78134e9d29a08a8bdc6">&#9670;&#160;</a></span>onEventCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onEventCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_event_script_line.html">RPG::EventScriptLine</a> *</td>          <td class="paramname"><span class="paramname"><em>scriptLine</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_event_script_data.html">RPG::EventScriptData</a> *</td>          <td class="paramname"><span class="paramname"><em>scriptData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>eventId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pageId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lineId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>nextLineId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before an event command is executed. </p>
<p>You can use this function to intercept event commands, use them for a different purpose or change their parameters.</p>
<p>By changing the <code>nextLineId</code>, you can decide which line in the script is to be executed next. By default, the value of <code>*nextLineId</code> is <code>-1</code>, which means that the default behavior is executed. You can change it to another line number to jump to a different line. Use <code>*nextLineId = lineId;</code> to repeat the command, this way you can create a "wait until done" behavior by initiating some action the first time and then repeatedly checking whether it is finished.</p>
<p>You can use the <code>scriptData</code> parameter to read other event commands in the current script. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scriptLine</td><td>The event script line which is about to be executed </td></tr>
    <tr><td class="paramname">scriptData</td><td>Pointer to the <a class="el" href="class_r_p_g_1_1_event_script_data.html" title="Class used for the event script data of an event.">RPG::EventScriptData</a> object of the current event script </td></tr>
    <tr><td class="paramname">eventId</td><td>The ID of the current event (negative for common events, zero for battle events) </td></tr>
    <tr><td class="paramname">pageId</td><td>The ID of the current event page (zero for common and battle events - sorry, no battle event page ID yet) </td></tr>
    <tr><td class="paramname">lineId</td><td>The zero-based line number </td></tr>
    <tr><td class="paramname">nextLineId</td><td>Pointer to the next executed line number (<code>-1</code> for default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent the event script line from being executed and other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>You may change the <code>scriptLine</code> object if you want, so that it is executed with different parameters. After the line was executed, all changes will be undone automatically.<br  />
<br  />
The "don't execute if you return false" feature works by setting bit 31 in the <code>command</code> member of the <code>scriptLine</code> so that it becomes an invalid (and thus ignored) command. DynRPG automatically clears this bit later. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not create loops which include several commands without a "Wait 0.0" (and also tell the user not to do so in case you provide an event command which jumps back in the script), otherwise the game will hang. If you loop to the <em>same</em> line using <code>*nextLineId = lineId;</code>, an automatic one-frame wait (equal to a "Wait 0.0") is inserted.<br  />
<br  />
Do not use the <code>nextLineId</code> member if the current event command calls another event or ends the current event (e.g. when the command is RPG::EVCMD_STOP_EVENT). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae23e92c109881bcec43cfb2838f3aead" title="Called when a &quot;Comment&quot; event command is encountered.">onComment</a> </dd></dl>

</div>
</div>
<a id="ga44c58b7f06ed7fc5c987a2008bbb8d52" name="ga44c58b7f06ed7fc5c987a2008bbb8d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44c58b7f06ed7fc5c987a2008bbb8d52">&#9670;&#160;</a></span>onEventDrawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onEventDrawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_character.html">RPG::Character</a> *</td>          <td class="paramname"><span class="paramname"><em>character</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isHero</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called after an event or the hero was drawn (or was supposed to be drawn) </p>
<p>You can use this function to draw something above a certain event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The character which was drawn or supposed to be drawn (can also be the hero) </td></tr>
    <tr><td class="paramname">isHero</td><td><code>true</code> if the <code>character</code> is the hero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function will be called regardless if a plugin returned <code>false</code> from its <a class="el" href="#ga32f6125de459664a48e7c39f088f9a51">onDrawEvent</a> handler for this event.<br  />
<br  />
Vehicles are not supported yet.<br  />
<br  />
This function is only called when the event is in sight <em>or</em> an <a class="el" href="#ga862305d7d40b374d0001a7aa47d7402f">onCheckEventVisibility</a> handler has returned <code>false</code> for this event. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga32f6125de459664a48e7c39f088f9a51" title="Called before an event or the hero is drawn.">onDrawEvent</a> </dd></dl>

</div>
</div>
<a id="gaf7dcec3988ba4d873f365b75373e5b09" name="gaf7dcec3988ba4d873f365b75373e5b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7dcec3988ba4d873f365b75373e5b09">&#9670;&#160;</a></span>onExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void onExit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before the game exits. </p>
<dl class="section note"><dt>Note</dt><dd>It's recommended to wrap your code in a <code>try..catch</code> block because if the game exits after an error (before <a class="el" href="#gae450b4810c6bb042969e4e15297c905f">onInitFinished</a> was called), the state of the memory is undefined. Also, if you want to save data, check whether there is anything to save before you do it. The <a class="el" href="namespace_r_p_g.html" title="The one and only namespace in which all DynRPG classes, variables and functions reside,...">RPG</a> objects may or may not be initialized, depending on whether this function is called before (early exit) or after <a class="el" href="#gae450b4810c6bb042969e4e15297c905f">onInitFinished</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This handler may also be called while another callback handler is active, in case the other handler is pumping messages (for example, it is currently displaying a message box). </dd></dl>

</div>
</div>
<a id="ga80ae5dd898c9423e63b28febef915cb4" name="ga80ae5dd898c9423e63b28febef915cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80ae5dd898c9423e63b28febef915cb4">&#9670;&#160;</a></span>onFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void onFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_r_p_g.html#a2385fd16f4ad88a4166fc9d04255a88c">RPG::Scene</a></td>          <td class="paramname"><span class="paramname"><em>scene</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called every frame, before the screen is refreshed (see details!) </p>
<p>This function is called after every frame (see details below!), right after the current game scene was drawn, but before it becomes visible to the player. You may draw on the screen in this function and it will appear on top of the normal graphics.</p>
<p>You can even define your own scene and use this callback to draw it.</p>
<p>However: <b>If the game is too slow, frames may be skipped</b>. If this happens, the screen is not refreshed every frame, to save time. In this case, the <code>onFrame</code> handler is called only when the screen is refreshed. You can use <a class="el" href="class_r_p_g_1_1_system.html#a0609f68ac83480d2522e270dddf2c174" title="Internal frame counter (see details!)">RPG::System::frameCounter</a> to find out how many frames were skipped (by comparing it with a value you saved at the last <code>onFrame</code> call), because when the scene is updated (even though the <code>onFrame</code> handler wasn't called), the <a class="el" href="class_r_p_g_1_1_system.html#a0609f68ac83480d2522e270dddf2c174" title="Internal frame counter (see details!)">RPG::System::frameCounter</a> will still be incremented. This way, the game won't be "slower" than normal even when the framerate drops below 60.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene</td><td>Game scene which was drawn </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code>scene</code> parameter does not necessarily equal to <code><a class="el" href="group__game__objects.html#ga0b269340fd77a259c0fe72e9e78d976a" title="Object of &quot;system&quot; data, used for values which can be changed in-game.">RPG::system</a>-&gt;scene</code>, e.g. when a transition from one scene to another is active. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_p_g_1_1_system.html#a44049724e2a072978dcc9d23b6f272c5" title="Current game scene (see RPG::Scene)">RPG::System::scene</a> </dd>
<dd>
<a class="el" href="class_r_p_g_1_1_system.html#a0609f68ac83480d2522e270dddf2c174" title="Internal frame counter (see details!)">RPG::System::frameCounter</a> </dd></dl>

</div>
</div>
<a id="gae450b4810c6bb042969e4e15297c905f" name="gae450b4810c6bb042969e4e15297c905f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae450b4810c6bb042969e4e15297c905f">&#9670;&#160;</a></span>onInitFinished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void onInitFinished </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called after the <a class="el" href="namespace_r_p_g.html" title="The one and only namespace in which all DynRPG classes, variables and functions reside,...">RPG</a> objects were initialized. </p>
<p>Unlike in <a class="el" href="#ga8a8edd989b9169752c0239bbadb3f9fd">onStartup</a>, it is safe to access <a class="el" href="namespace_r_p_g.html" title="The one and only namespace in which all DynRPG classes, variables and functions reside,...">RPG</a> objects from this function. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga8a8edd989b9169752c0239bbadb3f9fd" title="Called when the plugin was loaded.">onStartup</a> </dd></dl>

</div>
</div>
<a id="ga14a8ae4b9e3b382e3494773c670e3f19" name="ga14a8ae4b9e3b382e3494773c670e3f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14a8ae4b9e3b382e3494773c670e3f19">&#9670;&#160;</a></span>onInitTitleScreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void onInitTitleScreen </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before the title screen is initialized. </p>
<p>This function is called before the title screen fades in. </p>

</div>
</div>
<a id="gaf286710eea5356161c7790be7ca3e943" name="gaf286710eea5356161c7790be7ca3e943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf286710eea5356161c7790be7ca3e943">&#9670;&#160;</a></span>onLoadGame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void onLoadGame </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before the player loads a game from a savestate. </p>
<p>DynRPG loads plugin data which was previously saved in the <a class="el" href="#gaec141f78a287175b08e49f2e6b09e857">onSaveGame</a> function and passes it to this handler. See <a class="el" href="guidelines.html#ingame_data">In-game data</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Savestate ID </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to plugin data </td></tr>
    <tr><td class="paramname">length</td><td>Length of plugin data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>data</code> may be <code>0</code> if there is no data. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaf286710eea5356161c7790be7ca3e943" title="Called before the player loads a game from a savestate.">onLoadGame</a> </dd></dl>

</div>
</div>
<a id="gad54637c43929854413291a8e47a1c5ea" name="gad54637c43929854413291a8e47a1c5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad54637c43929854413291a8e47a1c5ea">&#9670;&#160;</a></span>onPictureDrawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onPictureDrawn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_p_g_1_1_picture.html">RPG::Picture</a> *</td>          <td class="paramname"><span class="paramname"><em>picture</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called after a picture was drawn (or was supposed to be drawn) </p>
<p>You can use this function to draw something above a certain picture. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">picture</td><td>The picture which is was drawn (or was supposed to be drawn) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function will be called regardless if a plugin returned <code>false</code> from its <a class="el" href="#gac6ad686df799b1dd99171611a62fd493">onDrawPicture</a> handler for this picture. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac6ad686df799b1dd99171611a62fd493" title="Called before a picture is drawn.">onDrawPicture</a> </dd></dl>

</div>
</div>
<a id="gaec141f78a287175b08e49f2e6b09e857" name="gaec141f78a287175b08e49f2e6b09e857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec141f78a287175b08e49f2e6b09e857">&#9670;&#160;</a></span>onSaveGame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void onSaveGame </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>savePluginData&#160;</em></span>)(char *data, int length)&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before the player saves a game. </p>
<p>Use the function passed in the <code>savePluginData</code> parameter to save custom plugin data which will be passed back to the plugin when the player loads the same savestate. See <a class="el" href="guidelines.html#ingame_data">In-game data</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Savestate ID </td></tr>
    <tr><td class="paramname">savePluginData</td><td>Call this function to save custom plugin data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If you call <code>savePluginData</code> more than once, only the last call will take effect. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaf286710eea5356161c7790be7ca3e943" title="Called before the player loads a game from a savestate.">onLoadGame</a> </dd></dl>

</div>
</div>
<a id="ga132e4983697a2aa0b0b979cc36e19d68" name="ga132e4983697a2aa0b0b979cc36e19d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga132e4983697a2aa0b0b979cc36e19d68">&#9670;&#160;</a></span>onSetSwitch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onSetSwitch </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before an in-game switch is set. </p>
<p>This function can be used to give "Change Switch" commands a special meaning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the switch to be changed </td></tr>
    <tr><td class="paramname">value</td><td>Value to be assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent the switch from being changed and other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This callback is not only triggered by the "Change Switch" command, but by any action which writes to a switch. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga78e95403edc3221cf53acafc5013db49" title="Called before an in-game variable is set.">onSetVariable</a> </dd></dl>

</div>
</div>
<a id="ga78e95403edc3221cf53acafc5013db49" name="ga78e95403edc3221cf53acafc5013db49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78e95403edc3221cf53acafc5013db49">&#9670;&#160;</a></span>onSetVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onSetVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called before an in-game variable is set. </p>
<p>This function can be used to give "Change Variable" commands a special meaning. This might be suitable for applications for which a full <a class="el" href="#gae23e92c109881bcec43cfb2838f3aead">onComment</a> implementation would be overkill, like a key check. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the variable to be changed </td></tr>
    <tr><td class="paramname">value</td><td>Value to be assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> will prevent the variable from being changed and other plugins from receiving this notification, use <code>true</code> otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This callback is not only triggered by the "Change Variable" command, but by any action which writes to a variable. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga132e4983697a2aa0b0b979cc36e19d68" title="Called before an in-game switch is set.">onSetSwitch</a> </dd></dl>

</div>
</div>
<a id="ga8a8edd989b9169752c0239bbadb3f9fd" name="ga8a8edd989b9169752c0239bbadb3f9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a8edd989b9169752c0239bbadb3f9fd">&#9670;&#160;</a></span>onStartup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onStartup </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>pluginName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when the plugin was loaded. </p>
<p>This callback handler should be used to check for fatal problems, like missing files. You can abort the loading process from this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pluginName</td><td>The name of the plugin. This is the filename with the extension stripped. For its supposed usage, see <a class="el" href="guidelines.html#configuration">Configuration</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on failure. In the latter case, other plugins which were already loaded will receive the <a class="el" href="#gaf7dcec3988ba4d873f365b75373e5b09">onExit</a> call and be unloaded and the game will not be started. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not try to access <a class="el" href="namespace_r_p_g.html" title="The one and only namespace in which all DynRPG classes, variables and functions reside,...">RPG</a> objects from this function, since the game hasn't been initialized yet. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gae450b4810c6bb042969e4e15297c905f" title="Called after the RPG objects were initialized.">onInitFinished</a> </dd>
<dd>
<a class="el" href="#gaf7dcec3988ba4d873f365b75373e5b09" title="Called before the game exits.">onExit</a> </dd></dl>

</div>
</div>
<a id="ga841f39d05129ab6f15b2d15358855f2a" name="ga841f39d05129ab6f15b2d15358855f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga841f39d05129ab6f15b2d15358855f2a">&#9670;&#160;</a></span>onSystemBackgroundDrawn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool onSystemBackgroundDrawn </td>
          <td>(</td>
          <td class="paramtype">RECT *</td>          <td class="paramname"><span class="paramname"><em>rect</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called after the system background was drawn. </p>
<p>This function can be used to draw your custom background in the menu, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>Area which has been (re)drawn </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In the save/load menu, there is only the small part at the top drawn, in the other menus, the whole screen is painted. Pay attention to the <code>rect</code> parameter. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.10.0-->
<!-- start footer part -->
<hr class="footer" />
<address class="footer"><small>
    Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg"
        width="104" height="31" alt="doxygen" /></a> 1.12.0
  </small></address>
</body>
</html>
